#version 430 core
#define BLOCKS_COUNT 8
#define MIN_MAX_FLOAT_MULTIPLIER 100000000.0

#define CELLS_A_WIDTH 2
#define CELLS_B_WIDTH 3
#define CELLS_C_WIDTH 4

#define NUM_CELLS_A CELLS_A_WIDTH * CELLS_A_WIDTH * CELLS_A_WIDTH
#define NUM_CELLS_B CELLS_B_WIDTH * CELLS_B_WIDTH * CELLS_B_WIDTH
#define NUM_CELLS_C CELLS_C_WIDTH * CELLS_C_WIDTH * CELLS_C_WIDTH

layout (local_size_x = BLOCKS_COUNT, local_size_y = BLOCKS_COUNT, local_size_z = BLOCKS_COUNT) in;
layout (rgba32f, binding = 0) uniform image3D ImgOutput;

layout (std140, binding = 1) uniform PointsPositions
{
    vec4 Points[NUM_CELLS_A + NUM_CELLS_B + NUM_CELLS_C];
};

layout(std140, binding = 2) buffer MinMaxValues
{
	int Mn;
	int Mx;
};

ivec3 offsets[] = 
{
	// bottom cells
	ivec3(-1, -1, -1),
	ivec3( 0, -1, -1),
	ivec3( 1, -1, -1),
	ivec3(-1, -1,  0),
	ivec3( 0, -1,  0),
	ivec3( 1, -1,  0),
	ivec3(-1, -1,  1),
	ivec3( 0, -1,  1),
	ivec3( 1, -1,  1),

	// same level cells
	ivec3(-1,  0, -1),
	ivec3( 0,  0, -1),
	ivec3( 1,  0, -1),
	ivec3(-1,  0,  0),
	ivec3( 0,  0,  0),
	ivec3( 1,  0,  0),
	ivec3(-1,  0,  1),
	ivec3( 0,  0,  1),
	ivec3( 1,  0,  1),

	// top cells
	ivec3(-1,  1, -1),
	ivec3( 0,  1, -1),
	ivec3( 1,  1, -1),
	ivec3(-1,  1,  0),
	ivec3( 0,  1,  0),
	ivec3( 1,  1,  0),
	ivec3(-1,  1,  1),
	ivec3( 0,  1,  1),
	ivec3( 1,  1,  1),
};

int minValue(ivec3 vec)
{
	return min(vec.x, min(vec.y, vec.z));
}

int maxValue(ivec3 vec)
{
	return max(vec.x, max(vec.y, vec.z));
}

float worley(int startIndex, int numCells, vec3 referencePosition)
{
	ivec3 referenceCell = ivec3(floor(referencePosition * numCells));
	float minSqrDist    = 10000.0;

	for (int offset = 0; offset < 27; offset++)
	{
		ivec3 currentCell = referenceCell + offsets[offset];
		if (minValue(currentCell) == -1 || maxValue(currentCell) == numCells)
		{
			// TODO: implement this
			//return 0.0f;
		}
		else
		{
			int  baseIndex     = (currentCell.z * numCells * numCells + currentCell.y * numCells + currentCell.x);
			int  adjustedIndex = startIndex + baseIndex;
			vec3 point         = Points[adjustedIndex].xyz;
			vec3 direction     = referencePosition - point;
			     minSqrDist    = min(minSqrDist, dot(direction, direction));
		}
	}

	return sqrt(minSqrDist);
}

void main()
{
	ivec3 pixelCoords = ivec3(gl_GlobalInvocationID);
	ivec3 imageSize   = imageSize(ImgOutput);

	if (pixelCoords.x >= imageSize.x || 
	    pixelCoords.y >= imageSize.y || 
		pixelCoords.z >= imageSize.z)
		return;

	vec3 normalizedCoords = vec3(pixelCoords.x / float(imageSize.x - 1), 
	     
		 pixelCoords.y / float(imageSize.y - 1),
				                 pixelCoords.z / float(imageSize.z - 1));

	float layerA = worley(0,                         CELLS_A_WIDTH, normalizedCoords);
	float layerB = worley(NUM_CELLS_A,               CELLS_B_WIDTH, normalizedCoords);
	float layerC = worley(NUM_CELLS_A + NUM_CELLS_B, CELLS_C_WIDTH, normalizedCoords);

	float persistance = 0.1;

	float sum         = layerA + layerB * persistance + layerC * persistance * persistance;
	      sum        /= 1 + persistance + persistance * persistance;
	      sum         = 1.0 - sum;

	atomicMin(Mn, int(sum * MIN_MAX_FLOAT_MULTIPLIER));
	atomicMax(Mx, int(sum * MIN_MAX_FLOAT_MULTIPLIER));
	
	imageStore(ImgOutput, pixelCoords, vec4(sum, sum, sum, 1.0));
}